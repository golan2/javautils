package javautils.graph.templates;

import javautils.graph.adt.Graph;
import javautils.graph.testing.TestGraphConstants;
import javautils.maps.ObjectToIntMap;
import junit.framework.TestCase;

/**
 * <p>A [<a href="{@docRoot}/overview-summary.html#[JUnit]">JUnit</a>]
 * test for {@link BfsTemplate}.</p>
 */
public class BfsTemplateTest extends TestCase implements TestGraphConstants {

  public static final String RSTUVWXY_GRAPH_BFS =
    "initNode(s)\n" +
    "initNode(r)\n" +
    "initNode(t)\n" +
    "initNode(u)\n" +
    "initNode(v)\n" +
    "initNode(w)\n" +
    "initNode(x)\n" +
    "initNode(y)\n" +
    "discoverRoot(s) {\n" +
    "*discoverNode(s,0)\n" +
    "-treeEdge(s,w)\n" +
    "-treeEdge(s,r)\n" +
    "*finishNode(s,0)\n" +
    " *discoverNode(w,1)\n" +
    " *discoverNode(r,1)\n" +
    " -treeEdge(w,t)\n" +
    " -treeEdge(w,x)\n" +
    " -nonTreeEdge(w,s)\n" +
    " *finishNode(w,1)\n" +
    " -nonTreeEdge(r,s)\n" +
    " -treeEdge(r,v)\n" +
    " *finishNode(r,1)\n" +
    "  *discoverNode(t,2)\n" +
    "  *discoverNode(x,2)\n" +
    "  *discoverNode(v,2)\n" +
    "  -nonTreeEdge(t,x)\n" +
    "  -nonTreeEdge(t,w)\n" +
    "  -treeEdge(t,u)\n" +
    "  *finishNode(t,2)\n" +
    "  -nonTreeEdge(x,w)\n" +
    "  -nonTreeEdge(x,t)\n" +
    "  -nonTreeEdge(x,u)\n" +
    "  -treeEdge(x,y)\n" +
    "  *finishNode(x,2)\n" +
    "  -nonTreeEdge(v,r)\n" +
    "  *finishNode(v,2)\n" +
    "   *discoverNode(u,3)\n" +
    "   *discoverNode(y,3)\n" +
    "   -nonTreeEdge(u,t)\n" +
    "   -nonTreeEdge(u,x)\n" +
    "   -nonTreeEdge(u,y)\n" +
    "   *finishNode(u,3)\n" +
    "   -nonTreeEdge(y,u)\n" +
    "   -nonTreeEdge(y,x)\n" +
    "   *finishNode(y,3)\n" +
    "} finishRoot(s)\n";

  /**
   * <p>Tests that the {@link BfsTemplate}-method gives the expected
   * transcript on the {@link TestGraphConstants#RSTUVWXY_GRAPH}.</p>
   */
  public void testBfsOnRSTUVWXY() {
    assertEquals(RSTUVWXY_GRAPH_BFS, bfsTranscript(RSTUVWXY_GRAPH));
  }

  public static final String CLOTHING_GRAPH_BFS =
    "initNode(belt)\n" +
    "initNode(jacket)\n" +
    "initNode(pants)\n" +
    "initNode(shirt)\n" +
    "initNode(shoes)\n" +
    "initNode(socks)\n" +
    "initNode(tie)\n" +
    "initNode(undershorts)\n" +
    "initNode(watch)\n" +
    "discoverRoot(belt) {\n" +
    "*discoverNode(belt,0)\n" +
    "-treeEdge(belt,jacket)\n" +
    "*finishNode(belt,0)\n" +
    " *discoverNode(jacket,1)\n" +
    " *finishNode(jacket,1)\n" +
    "} finishRoot(belt)\n" +
    "discoverRoot(pants) {\n" +
    "*discoverNode(pants,0)\n" +
    "-treeEdge(pants,shoes)\n" +
    "-nonTreeEdge(pants,belt)\n" +
    "*finishNode(pants,0)\n" +
    " *discoverNode(shoes,1)\n" +
    " *finishNode(shoes,1)\n" +
    "} finishRoot(pants)\n" +
    "discoverRoot(shirt) {\n" +
    "*discoverNode(shirt,0)\n" +
    "-treeEdge(shirt,tie)\n" +
    "-nonTreeEdge(shirt,belt)\n" +
    "*finishNode(shirt,0)\n" +
    " *discoverNode(tie,1)\n" +
    " -nonTreeEdge(tie,jacket)\n" +
    " *finishNode(tie,1)\n" +
    "} finishRoot(shirt)\n" +
    "discoverRoot(socks) {\n" +
    "*discoverNode(socks,0)\n" +
    "-nonTreeEdge(socks,shoes)\n" +
    "*finishNode(socks,0)\n" +
    "} finishRoot(socks)\n" +
    "discoverRoot(undershorts) {\n" +
    "*discoverNode(undershorts,0)\n" +
    "-nonTreeEdge(undershorts,pants)\n" +
    "-nonTreeEdge(undershorts,shoes)\n" +
    "*finishNode(undershorts,0)\n" +
    "} finishRoot(undershorts)\n" +
    "discoverRoot(watch) {\n" +
    "*discoverNode(watch,0)\n" +
    "*finishNode(watch,0)\n" +
    "} finishRoot(watch)\n";

  /**
   * <p>Tests that the {@link BfsTemplate}-method gives the expected
   * transcript on the {@link TestGraphConstants#CLOTHING_GRAPH}.</p>
   */
  public void testBfsOnCLOTHING() {
    assertEquals(CLOTHING_GRAPH_BFS, bfsTranscript(CLOTHING_GRAPH));
  }

  /*
   * <p>Generates a transcript of the events generated by the {@link
   * BfsTemplate}-method on the given graph.</p>
   */
  public static String bfsTranscript(final Graph g) {
    final StringBuffer result = new StringBuffer();

    new BfsTemplate() {
      ObjectToIntMap nodeToLevelMap = new ObjectToIntMap();

      protected void initNode(Object node) {
        result.append("initNode(" + node + ")\n");
      }

      protected void discoverRoot(Object node) {
        result.append("discoverRoot(" + node + ") {\n");
        nodeToLevelMap.put(node, 0);
      }

      protected void finishRoot(Object node) {
        result.append("} finishRoot(" + node + ")\n");
      }

      protected void discoverNode(Object node) {
        node(node, "discoverNode");
      }

      protected void finishNode(Object node) {
        node(node, "finishNode");
      }

      void node(Object node, String title) {
        int level = nodeToLevelMap.get(node);
        appendSpaces(level);
        result.append("*" + title + "(" + node + "," + level + ")\n");
      }

      protected void treeEdge(Object edge) {
        nodeToLevelMap.put(g.targetOf(edge), nodeToLevelMap.get(g.sourceOf(edge))+1);
        edge(edge, "treeEdge");
      }

      protected void nonTreeEdge(Object edge) {
        edge(edge, "nonTreeEdge");
      }

      void edge(Object edge, String title) {
        appendSpaces(nodeToLevelMap.get(g.sourceOf(edge)));
        result.append("-" + title + "(" + g.sourceOf(edge) + "," + g.targetOf(edge) +")\n");
      }

      void appendSpaces(int n) {
        while (0 <= --n)
          result.append(' ');
      }
    }.search(g);

    return result.toString();
  }
}
